// @source: xyz-d50
// @target: lab
// @description: Converts CIE XYZ D50 to CIE Lab using standard CIE algorithm
// @lossless: True
// @end

// === Input Processing ===
variable xyz: List = {input}.x, {input}.y, {input}.z;
variable X: Number = xyz.get(0);  // X tristimulus value
variable Y: Number = xyz.get(1);  // Y tristimulus value (luminance)
variable Z: Number = xyz.get(2);  // Z tristimulus value

// === Working Variables ===
variable lab: List = 0, 0, 0;

// === CIE Standard Illuminant D50 White Point ===
// Reference: CIE 15:2004 "Colorimetry"
variable Xn: Number = 0.9642;   // D50 white point X
variable Yn: Number = 1.0000;   // D50 white point Y
variable Zn: Number = 0.8249;   // D50 white point Z

// === XYZ D50 to Lab Conversion Algorithm ===
// Based on: CIE 15:2004 "Colorimetry" standard
// Formula uses cube root transformation with linear segment for small values

// Step 1: Normalize XYZ values relative to white point
variable x_norm: Number = X / Xn;
variable y_norm: Number = Y / Yn;
variable z_norm: Number = Z / Zn;

// === CIE Lab Transform Function ===
// Apply f(t) transformation where:
//   f(t) = t^(1/3) if t > (6/29)³
//   f(t) = (1/3)(29/6)²t + (4/29) if t ≤ (6/29)³

// Constants for Lab transformation
variable delta: Number = 6.0 / 29.0;           // δ = 6/29
variable delta_cubed: Number = delta * delta * delta;  // δ³ = (6/29)³
variable linear_coefficient: Number = (29.0 / 6.0) * (29.0 / 6.0) / 3.0;  // (29/6)²/3
variable linear_offset: Number = 4.0 / 29.0;   // 4/29

// Step 2: Transform X component
variable fx: Number = 0;
if (x_norm > delta_cubed) [
    fx = pow(x_norm, 1.0/3.0);
] else [
    fx = linear_coefficient * x_norm + linear_offset;
];

// Step 3: Transform Y component
variable fy: Number = 0;
if (y_norm > delta_cubed) [
    fy = pow(y_norm, 1.0/3.0);
] else [
    fy = linear_coefficient * y_norm + linear_offset;
];

// Step 4: Transform Z component
variable fz: Number = 0;
if (z_norm > delta_cubed) [
    fz = pow(z_norm, 1.0/3.0);
] else [
    fz = linear_coefficient * z_norm + linear_offset;
];

// === Lab Component Calculation ===
// Step 5: Calculate Lab values using transformed components
variable L: Number = 116 * fy - 16;  // Lightness [0,100]
variable a: Number = 500 * (fx - fy); // Green-Red axis
variable b: Number = 200 * (fy - fz); // Blue-Yellow axis

// Step 6: Store final Lab values
lab.update(0, L);  // Lightness
lab.update(1, a);  // a* component
lab.update(2, b);  // b* component

// === Output Construction ===
variable output: Color.Lab;
output.l = lab.get(0);
output.a = lab.get(1);
output.b = lab.get(2);

return output;