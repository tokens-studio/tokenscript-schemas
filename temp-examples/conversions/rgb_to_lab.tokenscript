// @source: srgb
// @target: lab
// @description: Converts sRGB to CIE Lab via linear sRGB, XYZ D65, and chromatic adaptation
// @lossless: True
// @end

// === Input Processing ===
variable srgb: List = {input}.r, {input}.g, {input}.b;

// === Working Variables ===
variable lab: List = 0, 0, 0;

// === sRGB to CIE Lab Conversion Algorithm ===
// Multi-step process: sRGB → Linear sRGB → XYZ D65 → XYZ D50 → Lab
// Based on: sRGB specification and CIE 15:2004 "Colorimetry"

// === Step 1: sRGB to Linear sRGB (Inverse Gamma Correction) ===
// Normalize RGB values to [0,1] range
variable r: Number = srgb.get(0) / 255;
variable g: Number = srgb.get(1) / 255;
variable b: Number = srgb.get(2) / 255;

// sRGB inverse gamma correction constants
variable gamma_threshold: Number = 0.04045;
variable linear_coefficient: Number = 12.92;
variable gamma_scale: Number = 1.055;
variable gamma_exponent: Number = 2.4;
variable gamma_offset: Number = 0.055;

// Process red component
variable r_linear: Number = 0;
if (r <= gamma_threshold) [
    r_linear = r / linear_coefficient;
] else [
    r_linear = pow((r + gamma_offset) / gamma_scale, gamma_exponent);
];

// Process green component
variable g_linear: Number = 0;
if (g <= gamma_threshold) [
    g_linear = g / linear_coefficient;
] else [
    g_linear = pow((g + gamma_offset) / gamma_scale, gamma_exponent);
];

// Process blue component
variable b_linear: Number = 0;
if (b <= gamma_threshold) [
    b_linear = b / linear_coefficient;
] else [
    b_linear = pow((b + gamma_offset) / gamma_scale, gamma_exponent);
];

// === Step 2: Linear sRGB to XYZ D65 ===
// sRGB to XYZ transformation matrix (D65 illuminant)
variable X_d65: Number = 0.4124 * r_linear + 0.3576 * g_linear + 0.1805 * b_linear;
variable Y_d65: Number = 0.2126 * r_linear + 0.7152 * g_linear + 0.0722 * b_linear;
variable Z_d65: Number = 0.0193 * r_linear + 0.1192 * g_linear + 0.9505 * b_linear;

// === Step 3: Chromatic Adaptation D65 → D50 ===
// Bradford transformation matrix for D65 → D50 adaptation
variable X_d50: Number = 1.0478112 * X_d65 + 0.0228866 * Y_d65 - 0.0501270 * Z_d65;
variable Y_d50: Number = 0.0295424 * X_d65 + 0.9904844 * Y_d65 - 0.0170491 * Z_d65;
variable Z_d50: Number = -0.0092596 * X_d65 + 0.0150436 * Y_d65 + 0.7521316 * Z_d65;

// === Step 4: XYZ D50 to Lab Conversion ===
// CIE Standard Illuminant D50 White Point
variable Xn_d50: Number = 0.9642;   // D50 white point X
variable Yn_d50: Number = 1.0000;   // D50 white point Y
variable Zn_d50: Number = 0.8249;   // D50 white point Z

// Normalize XYZ values relative to white point
variable x_norm: Number = X_d50 / Xn_d50;
variable y_norm: Number = Y_d50 / Yn_d50;
variable z_norm: Number = Z_d50 / Zn_d50;

// Constants for Lab transformation
variable delta: Number = 6.0 / 29.0;           // δ = 6/29
variable delta_cubed: Number = delta * delta * delta;  // δ³ = (6/29)³
variable linear_coeff: Number = (29.0 / 6.0) * (29.0 / 6.0) / 3.0;  // (29/6)²/3
variable linear_offset: Number = 4.0 / 29.0;   // 4/29

// Transform X component
variable fx: Number = 0;
if (x_norm > delta_cubed) [
    fx = pow(x_norm, 1.0/3.0);
] else [
    fx = linear_coeff * x_norm + linear_offset;
];

// Transform Y component
variable fy: Number = 0;
if (y_norm > delta_cubed) [
    fy = pow(y_norm, 1.0/3.0);
] else [
    fy = linear_coeff * y_norm + linear_offset;
];

// Transform Z component
variable fz: Number = 0;
if (z_norm > delta_cubed) [
    fz = pow(z_norm, 1.0/3.0);
] else [
    fz = linear_coeff * z_norm + linear_offset;
];

// === Lab Component Calculation ===
// Calculate Lab values using transformed components
variable L: Number = 116 * fy - 16;  // Lightness [0,100]
variable a: Number = 500 * (fx - fy); // Green-Red axis
variable b_lab: Number = 200 * (fy - fz); // Blue-Yellow axis

// Store final Lab values
lab.update(0, L);      // Lightness
lab.update(1, a);      // a* component
lab.update(2, b_lab);  // b* component

// === Output Construction ===
variable output: Color.Lab;
output.l = lab.get(0);
output.a = lab.get(1);
output.b = lab.get(2);

return output;