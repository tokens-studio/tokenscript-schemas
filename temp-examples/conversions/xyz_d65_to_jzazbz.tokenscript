// @source: xyz-d65
// @target: jzazbz
// @description: Converts CIE XYZ D65 to Jzazbz using perceptual color space transformation
// @lossless: True
// @end

// === Input Processing ===
variable xyz: List = {input}.x, {input}.y, {input}.z;
variable X: Number = xyz.get(0);  // X tristimulus value
variable Y: Number = xyz.get(1);  // Y tristimulus value (luminance)
variable Z: Number = xyz.get(2);  // Z tristimulus value

// === Working Variables ===
variable jzazbz: List = 0, 0, 0;

// === XYZ D65 to Jzazbz Conversion Algorithm ===
// Based on: Safdar et al. (2017) "Perceptually uniform color space for image signals including high dynamic range and wide gamut"
// Reference: https://doi.org/10.1364/OE.25.015131

// === Step 1: XYZ D65 to XYZ D65 (Absolute) ===
// Normalize to absolute luminance (assuming 100 cd/mÂ²)
variable X_abs: Number = X;
variable Y_abs: Number = Y;
variable Z_abs: Number = Z;

// === Step 2: XYZ to LMS Transformation ===
// Hunt-Pointer-Estevez matrix for XYZ to LMS conversion
variable L: Number = 0.41478972 * X_abs + 0.579999 * Y_abs + 0.014648 * Z_abs;
variable M: Number = -0.20151 * X_abs + 1.120649 * Y_abs + 0.0531008 * Z_abs;
variable S: Number = -0.0166008 * X_abs + 0.2648 * Y_abs + 0.6684799 * Z_abs;

// === Step 3: LMS to L'M'S' (Perceptual Encoding) ===
// Apply perceptual transform: f(x) = ((c1 + c2 * (x/10000)^n) / (1 + c3 * (x/10000)^n))^p
variable c1: Number = 3424.0 / 4096.0;
variable c2: Number = 2413.0 / 4096.0 * 32.0;
variable c3: Number = 2392.0 / 4096.0 * 32.0;
variable n: Number = 2610.0 / 4096.0 * 1.0/4.0;
variable p: Number = 1.7 * 2523.0 / 4096.0;
variable d: Number = -0.56;
variable d0: Number = 1.6295499532821566e-11;

// Apply PQ EOTF to LMS values
variable L_norm: Number = L / 10000;
variable M_norm: Number = M / 10000;
variable S_norm: Number = S / 10000;

// PQ transform function for each component
variable L_n: Number = pow(L_norm, n);
variable M_n: Number = pow(M_norm, n);
variable S_n: Number = pow(S_norm, n);

variable L_prime: Number = pow((c1 + c2 * L_n) / (1 + c3 * L_n), p);
variable M_prime: Number = pow((c1 + c2 * M_n) / (1 + c3 * M_n), p);
variable S_prime: Number = pow((c1 + c2 * S_n) / (1 + c3 * S_n), p);

// === Step 4: L'M'S' to Izazbz (Intermediate) ===
// LMS to Izazbz transformation matrix
variable Iz: Number = 0.5 * L_prime + 0.5 * M_prime;
variable az: Number = 3.524000 * L_prime - 4.066708 * M_prime + 0.542708 * S_prime;
variable bz: Number = 0.199076 * L_prime + 1.096799 * M_prime - 1.295875 * S_prime;

// === Step 5: Izazbz to Jzazbz (Final Perceptual) ===
// Apply final perceptual scaling
variable Jz: Number = (1 + d) * Iz / (1 + d * Iz) - d0;

// Store final Jzazbz values
jzazbz.update(0, Jz);  // Jz (lightness)
jzazbz.update(1, az);  // az (green-red)
jzazbz.update(2, bz);  // bz (blue-yellow)

// === Output Construction ===
variable output: Color.Jzazbz;
output.jz = jzazbz.get(0);
output.az = jzazbz.get(1);
output.bz = jzazbz.get(2);

return output;