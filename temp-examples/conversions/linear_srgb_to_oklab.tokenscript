// @source: linear-srgb
// @target: oklab
// @description: Converts Linear sRGB to OKLab using Ottosson's algorithm
// @lossless: True
// @end

// === Input Processing ===
variable linear_srgb: List = {input}.r, {input}.g, {input}.b;
variable r: Number = linear_srgb.get(0);  // Linear red component
variable g: Number = linear_srgb.get(1);  // Linear green component
variable b: Number = linear_srgb.get(2);  // Linear blue component

// === Working Variables ===
variable oklab: List = 0, 0, 0;

// === Linear sRGB to OKLab Conversion Algorithm ===
// Based on: Björn Ottosson's OKLab color space specification
// Reference: https://bottosson.github.io/posts/oklab/

// Step 1: Transform from Linear sRGB to LMS cone response space
// Using transformation matrix derived from CIE XYZ D65
variable l: Number = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
variable m: Number = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
variable s: Number = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;

// Step 2: Apply cube root transformation to LMS values
// l' = ∛l, m' = ∛m, s' = ∛s
variable l_: Number = pow(abs(l), 1/3);
variable m_: Number = pow(abs(m), 1/3);
variable s_: Number = pow(abs(s), 1/3);

// Handle negative values by preserving sign
if (l < 0) [ l_ = -l_; ];
if (m < 0) [ m_ = -m_; ];
if (s < 0) [ s_ = -s_; ];

// Step 3: Transform from cube root LMS to OKLab
// Using OKLab transformation matrix
variable L: Number = 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_;
variable a: Number = 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_;
variable b_oklab: Number = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_;

// Step 4: Store final OKLab values
oklab.update(0, L);        // Lightness [0,1]
oklab.update(1, a);        // Green-Red axis
oklab.update(2, b_oklab);  // Blue-Yellow axis

// === Output Construction ===
variable output: Color.OKLab;
output.l = oklab.get(0);
output.a = oklab.get(1);
output.b = oklab.get(2);

return output;