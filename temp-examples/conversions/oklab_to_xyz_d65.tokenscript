// @source: oklab
// @target: xyz-d65
// @description: Converts OKLab to XYZ-D65 using inverse of Björn Ottosson's specification
// @lossless: True
// @end

// === Input Processing ===
variable oklab: List = {input}.l, {input}.a, {input}.b;
variable L: Number = oklab.get(0);  // Lightness component
variable a: Number = oklab.get(1);  // Green-red axis component
variable b: Number = oklab.get(2);  // Blue-yellow axis component

// === Working Variables ===
variable xyz_d65: List = 0, 0, 0;

// === OKLab to XYZ-D65 Conversion Algorithm ===
// Based on: "A perceptual color space for image processing" by Björn Ottosson
// Reference: https://bottosson.github.io/posts/oklab/
// This is the inverse transformation of XYZ-D65 → OKLab

// Step 1: OKLab to LMS' using M2 inverse matrix
// Inverse of the M2 matrix that transforms LMS' to OKLab
variable lms_l_prime: Number = L + 0.3963377774 * a + 0.2158037573 * b;
variable lms_m_prime: Number = L - 0.1055613458 * a - 0.0638541728 * b;
variable lms_s_prime: Number = L - 0.0894841775 * a - 1.2914855480 * b;

// Step 2: Apply inverse cube root (cube the values) to get LMS
// Reverse the cube root transformation: LMS' → LMS
variable lms_l: Number = pow(lms_l_prime, 3);
variable lms_m: Number = pow(lms_m_prime, 3);
variable lms_s: Number = pow(lms_s_prime, 3);

// Step 3: LMS to XYZ-D65 using M1 inverse matrix
// Inverse of the M1 matrix that transforms XYZ-D65 to LMS
variable x: Number = 1.2270138511 * lms_l - 0.5577999807 * lms_m + 0.2812561490 * lms_s;
variable y: Number = -0.0405801784 * lms_l + 1.1122568696 * lms_m - 0.0716766787 * lms_s;
variable z: Number = -0.0763812845 * lms_l - 0.4214819784 * lms_m + 1.5861632204 * lms_s;

// Update XYZ list with calculated values
xyz_d65.update(0, x);
xyz_d65.update(1, y);
xyz_d65.update(2, z);

// === Output Construction ===
variable output: Color.XYZD65;
output.x = xyz_d65.get(0);
output.y = xyz_d65.get(1);
output.z = xyz_d65.get(2);

return output;