// OKLab to OKHSL Conversion
// Reference: Björn Ottosson - "A perceptual color picker: OKHSL and OKHSV"
// URL: https://bottosson.github.io/posts/colorpicker/
// Reference: https://github.com/color-js/color.js/blob/main/src/spaces/okhsl.js
//
// OKHSL is a perceptually uniform HSL model based on OKLab that maps the entire
// sRGB gamut to a cylinder. Unlike regular HSL:
// - Lightness is perceptually uniform (from OKLab)
// - Saturation is normalized relative to the sRGB gamut boundary at each hue
// - Equal steps in S produce visually equal chroma changes within the gamut
//
// Algorithm overview:
// 1. Convert OKLab (L, a, b) to polar form (L, C, H)
// 2. Apply toe function to lightness: l = toe(L) for perceptual uniformity
// 3. Find the maximum chroma C_max at this hue and lightness
// 4. Normalize saturation: S = C / C_max
//
// Input: Color.OKLab with l (0-1), a, b coordinates
// Output: Color.OKHSL with h (0-360), s (0-1), l (0-1)

variable lab_l: Number = input.l;
variable lab_a: Number = input.a;
variable lab_b: Number = input.b;

// Use native PI constant
variable pi: Number = pi();

// ═══════════════════════════════════════════════════════════════════════════
// Step 1: Convert to polar coordinates (L, C, H)
// ═══════════════════════════════════════════════════════════════════════════
variable c: Number = sqrt(lab_a * lab_a + lab_b * lab_b);
variable h: Number = 0;

// Calculate hue from a, b using atan2
// Handle achromatic case (c ≈ 0) by keeping h = 0
if (c > 0.00001) [
  h = atan2(lab_b, lab_a) * 180 / pi;
  if (h < 0) [
    h = h + 360;
  ];
];

// ═══════════════════════════════════════════════════════════════════════════
// Step 2: Apply toe function to lightness
// Reference: Ottosson's toe function for perceptually uniform lightness scale
//
// toe(x) = 0.5 * (k3*x - k1 + sqrt((k3*x - k1)^2 + 4*k2*k3*x))
// where k1 = 0.206, k2 = 0.03, k3 = (1+k1)/(1+k2)
//
// This makes the lightness scale more perceptually uniform, especially
// near black where human vision is more sensitive to changes.
// ═══════════════════════════════════════════════════════════════════════════
variable k1: Number = 0.206;
variable k2: Number = 0.03;
variable k3: Number = 1.17009708737864;  // (1 + k1) / (1 + k2)

variable l_toe: Number = lab_l;
if (lab_l > 0.0001 && lab_l < 0.9999) [
  // Apply toe function
  variable term1: Number = k3 * lab_l - k1;
  variable term2: Number = term1 * term1 + 4 * k2 * k3 * lab_l;
  l_toe = 0.5 * (term1 + sqrt(term2));
];

// ═══════════════════════════════════════════════════════════════════════════
// Step 3: Find maximum chroma at this hue for the sRGB gamut
//
// The sRGB gamut boundary in OKLab space varies with hue and lightness.
// At L=0 (black) and L=1 (white), C_max = 0.
// At mid-lightness, C_max is highest (the "cusp" of the gamut).
//
// For a proper implementation, we would:
// 1. Find the cusp (L_cusp, C_cusp) for this hue using find_cusp()
// 2. Compute C_max at the current L based on the gamut shape
//
// Simplified approximation (documented limitation):
// We estimate C_max based on typical sRGB gamut shape. The actual algorithm
// requires computing where the OKLab-to-sRGB matrix produces clipping.
//
// TODO: Implement proper cusp finding as per Ottosson's reference code
// ═══════════════════════════════════════════════════════════════════════════

// Normalized hue direction
variable h_rad: Number = h * pi / 180;
variable a_: Number = cos(h_rad);
variable b_: Number = sin(h_rad);

// Approximate cusp location varies by hue
// Red/Magenta hues have cusp around L ≈ 0.55-0.65
// Yellow hues have cusp around L ≈ 0.95-0.97
// Blue hues have cusp around L ≈ 0.3-0.4
// This is a simplified model - real gamut boundary is complex

variable cusp_l: Number = 0.65;  // Average cusp lightness
variable cusp_c: Number = 0.37;  // Average cusp chroma

// Adjust cusp based on hue (approximate variation)
// Yellow (h ≈ 110) has high cusp, Blue (h ≈ 265) has low cusp
if (h > 80 && h < 140) [
  cusp_l = 0.92;
  cusp_c = 0.25;
];
if (h > 200 && h < 300) [
  cusp_l = 0.35;
  cusp_c = 0.32;
];

// Compute C_max at current lightness
// The gamut shape is roughly triangular in the L-C plane
// C_max(L) = C_cusp * min(L/L_cusp, (1-L)/(1-L_cusp))
variable c_max: Number = 0;
if (lab_l <= cusp_l && cusp_l > 0.001) [
  c_max = cusp_c * (lab_l / cusp_l);
] else [
  if (cusp_l < 0.999) [
    c_max = cusp_c * ((1 - lab_l) / (1 - cusp_l));
  ];
];

// Ensure minimum to avoid division by zero
if (c_max < 0.0001) [
  c_max = 0.0001;
];

// ═══════════════════════════════════════════════════════════════════════════
// Step 4: Calculate normalized saturation
// S = C / C_max (ratio of actual chroma to gamut boundary)
// ═══════════════════════════════════════════════════════════════════════════
variable s: Number = c / c_max;
if (s > 1) [
  s = 1;
];

// ═══════════════════════════════════════════════════════════════════════════
// Output: OKHSL color
// ═══════════════════════════════════════════════════════════════════════════
variable output: Color.OKHSL;
output.h = h;
output.s = s;
output.l = l_toe;
output
