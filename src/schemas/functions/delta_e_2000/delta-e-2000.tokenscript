// CIEDE2000 Color Difference Formula (ΔE00)
// Reference: CIE 142-2001 (Technical Report)
// Reference: Color.js deltaE2000 implementation
// Reference: Sharma, Wu, Dalal "The CIEDE2000 Color-Difference Formula" (2005)
//
// This is the CIE-recommended color difference formula, providing
// better correlation with visual perception than CIE76 or CIE94.
//
// Parametric factors (kL, kC, kH):
// - All default to 1.0 for reference conditions
// - kL can be increased for lightness texture/noise
// - kC can be increased for chroma noise
//
// Interpretation (approximate):
//   0.0        - Identical colors
//   < 1.0      - Not perceptible by human eye
//   1.0 - 2.0  - Perceptible through close observation
//   2.0 - 10.0 - Perceptible at a glance
//   > 10.0     - Colors are obviously different

variable input: List = {input};

// Convert both colors to CIE Lab
variable color1: Color.Lab = input.get(0).to.lab();
variable color2: Color.Lab = input.get(1).to.lab();

// Get parametric weighting factors (default to 1)
variable k_l: Number = 1;
variable k_c: Number = 1;
variable k_h: Number = 1;
if (input.length() > 2) [ k_l = input.get(2); ];
if (input.length() > 3) [ k_c = input.get(3); ];
if (input.length() > 4) [ k_h = input.get(4); ];

// Constants
variable pi: Number = pi();
variable r2d: Number = 180 / pi;
variable d2r: Number = pi / 180;
variable g_factor: Number = 6103515625; // 25^7
variable e: Number = 2.718281828459045; // Euler's number

// Get Lab values
variable l1: Number = color1.l;
variable a1: Number = color1.a;
variable b1: Number = color1.b;

variable l2: Number = color2.l;
variable a2: Number = color2.a;
variable b2: Number = color2.b;

// Calculate C* (chroma) for both colors
variable c1: Number = sqrt(a1 * a1 + b1 * b1);
variable c2: Number = sqrt(a2 * a2 + b2 * b2);

// Ensure non-negative chroma
if (c1 < 0) [ c1 = 0; ];
if (c2 < 0) [ c2 = 0; ];

// Mean chroma
variable c_bar: Number = (c1 + c2) / 2;

// Calculate G (a-axis asymmetry factor)
variable c7: Number = c_bar * c_bar * c_bar * c_bar * c_bar * c_bar * c_bar;
variable g: Number = 0.5 * (1 - sqrt(c7 / (c7 + g_factor)));

// Scale a* values by asymmetry factor
variable a_prime1: Number = (1 + g) * a1;
variable a_prime2: Number = (1 + g) * a2;

// Calculate C' from scaled a' and original b
variable c_prime1: Number = sqrt(a_prime1 * a_prime1 + b1 * b1);
variable c_prime2: Number = sqrt(a_prime2 * a_prime2 + b2 * b2);

// Calculate h' (hue angles in degrees)
variable h1: Number = 0;
if (a_prime1 != 0) [ h1 = atan2(b1, a_prime1); ];
if (b1 != 0) [ h1 = atan2(b1, a_prime1); ];
if (a_prime1 == 0) [
    if (b1 == 0) [ h1 = 0; ] else [ h1 = atan2(b1, a_prime1); ];
];
h1 = h1 * r2d;
if (h1 < 0) [ h1 = h1 + 360; ];

variable h2: Number = 0;
if (a_prime2 != 0) [ h2 = atan2(b2, a_prime2); ];
if (b2 != 0) [ h2 = atan2(b2, a_prime2); ];
if (a_prime2 == 0) [
    if (b2 == 0) [ h2 = 0; ] else [ h2 = atan2(b2, a_prime2); ];
];
h2 = h2 * r2d;
if (h2 < 0) [ h2 = h2 + 360; ];

// Lightness and Chroma differences
variable delta_l: Number = l2 - l1;
variable delta_c: Number = c_prime2 - c_prime1;

// Hue difference (getting the sign correct)
variable h_diff: Number = h2 - h1;
variable h_sum: Number = h1 + h2;
variable h_abs: Number = h_diff;
if (h_abs < 0) [ h_abs = 0 - h_abs; ];

variable delta_h: Number = 0;
variable c_product: Number = c_prime1 * c_prime2;

if (c_product == 0) [
    delta_h = 0;
] else [
    if (h_abs <= 180) [
        delta_h = h_diff;
    ] else [
        if (h_diff > 180) [
            delta_h = h_diff - 360;
        ] else [
            if (h_diff < -180) [
                delta_h = h_diff + 360;
            ] else [
                delta_h = h_diff;
            ];
        ];
    ];
];

// Weighted hue difference (ΔH')
variable delta_h_prime: Number = 2 * sqrt(c_prime2 * c_prime1) * sin(delta_h * d2r / 2);

// Mean lightness and chroma
variable l_bar: Number = (l1 + l2) / 2;
variable c_bar_prime: Number = (c_prime1 + c_prime2) / 2;
variable c_bar_prime7: Number = c_bar_prime * c_bar_prime * c_bar_prime * c_bar_prime * c_bar_prime * c_bar_prime * c_bar_prime;

// Mean hue (handling the 0/360 wraparound)
variable h_bar: Number = 0;
if (c_product == 0) [
    h_bar = h_sum;
] else [
    if (h_abs <= 180) [
        h_bar = h_sum / 2;
    ] else [
        if (h_sum < 360) [
            h_bar = (h_sum + 360) / 2;
        ] else [
            h_bar = (h_sum - 360) / 2;
        ];
    ];
];

// SL - Lightness crispening factor (assumes L=50 background)
variable l_bar_minus_50: Number = l_bar - 50;
variable l_sq: Number = l_bar_minus_50 * l_bar_minus_50;
variable s_l: Number = 1 + (0.015 * l_sq) / sqrt(20 + l_sq);

// SC - Chroma factor
variable s_c: Number = 1 + 0.045 * c_bar_prime;

// T - Cross term for blue non-linearity
variable t: Number = 1;
t = t - 0.17 * cos((h_bar - 30) * d2r);
t = t + 0.24 * cos(2 * h_bar * d2r);
t = t + 0.32 * cos((3 * h_bar + 6) * d2r);
t = t - 0.20 * cos((4 * h_bar - 63) * d2r);

// SH - Hue factor
variable s_h: Number = 1 + 0.015 * c_bar_prime * t;

// RT - Hue rotation term (for blue region 225-315 degrees)
variable h_bar_minus_275: Number = h_bar - 275;
variable exp_arg: Number = -1 * (h_bar_minus_275 / 25) * (h_bar_minus_275 / 25);
variable delta_theta: Number = 30 * pow(e, exp_arg);
variable r_c: Number = 2 * sqrt(c_bar_prime7 / (c_bar_prime7 + g_factor));
variable r_t: Number = -1 * sin(2 * delta_theta * d2r) * r_c;

// Calculate final ΔE00
variable term_l: Number = delta_l / (k_l * s_l);
variable term_c: Number = delta_c / (k_c * s_c);
variable term_h: Number = delta_h_prime / (k_h * s_h);

variable de: Number = term_l * term_l + term_c * term_c + term_h * term_h;
de = de + r_t * (delta_c / (k_c * s_c)) * (delta_h_prime / (k_h * s_h));

variable result: Number = sqrt(de);

return result;

