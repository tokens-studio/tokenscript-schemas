// match_alpha: Find alpha that produces a reference color when blending
// Reference: Reverse Porter-Duff compositing
//
// Given: result = foreground × α + background × (1 - α)
// Solve for α: α = (result - background) / (foreground - background)
//
// The alpha is computed per-channel (in sRGB for calculation) and averaged.
// Returns a list: [in_range (0 or 1), alpha, foreground_color]
//
// Input:  Any color space
// Output: Same color space as input (foreground color returned unchanged)
//
// Returns: [in_range, alpha, foreground_color]
// - in_range: 1 if blend is achievable, 0 if not
// - alpha: The computed opacity value
// - foreground_color: Original foreground (apply alpha yourself to preserve space)
//
// Use cases:
// - Reverse-engineering transparency from flattened designs
// - Finding opacity to match a specific tint/shade
// - Color matching in compositing workflows

variable input: List = {input};
// Convert to sRGB for alpha calculation, preserve original for return
variable fg: Color.SRGB = input.get(0).to.srgb();
variable bg: Color.SRGB = input.get(1).to.srgb();
variable ref: Color.SRGB = input.get(2).to.srgb();

// Precision for comparing values (default 0.01)
variable precision: Number = 0.01;
if (input.length() > 3) [
    precision = input.get(3);
];

variable alpha: Number = 0;
variable in_range: Number = 0;
variable valid_channels: Number = 0;
variable alpha_sum: Number = 0;

// Calculate alpha for each channel (R, G, B)
// α = (ref - bg) / (fg - bg)

// Red channel
variable r_diff: Number = fg.r - bg.r;
variable r_alpha: Number = -1;
if (r_diff > precision) [
    r_alpha = (ref.r - bg.r) / r_diff;
] else [
    if (r_diff < (0 - precision)) [
        r_alpha = (ref.r - bg.r) / r_diff;
    ];
];

// Green channel
variable g_diff: Number = fg.g - bg.g;
variable g_alpha: Number = -1;
if (g_diff > precision) [
    g_alpha = (ref.g - bg.g) / g_diff;
] else [
    if (g_diff < (0 - precision)) [
        g_alpha = (ref.g - bg.g) / g_diff;
    ];
];

// Blue channel
variable b_diff: Number = fg.b - bg.b;
variable b_alpha: Number = -1;
if (b_diff > precision) [
    b_alpha = (ref.b - bg.b) / b_diff;
] else [
    if (b_diff < (0 - precision)) [
        b_alpha = (ref.b - bg.b) / b_diff;
    ];
];

// Validate and average alphas
// Only count channels where fg != bg (significant difference)
if (r_alpha >= 0) [
    if (r_alpha <= 1) [
        alpha_sum = alpha_sum + r_alpha;
        valid_channels = valid_channels + 1;
    ];
];

if (g_alpha >= 0) [
    if (g_alpha <= 1) [
        alpha_sum = alpha_sum + g_alpha;
        valid_channels = valid_channels + 1;
    ];
];

if (b_alpha >= 0) [
    if (b_alpha <= 1) [
        alpha_sum = alpha_sum + b_alpha;
        valid_channels = valid_channels + 1;
    ];
];

// Check if reference equals background (alpha = 0 case)
variable bg_matches_ref: Number = 1;
variable r_bg_diff: Number = bg.r - ref.r;
if (r_bg_diff < 0) [ r_bg_diff = 0 - r_bg_diff; ];
if (r_bg_diff > precision) [ bg_matches_ref = 0; ];

variable g_bg_diff: Number = bg.g - ref.g;
if (g_bg_diff < 0) [ g_bg_diff = 0 - g_bg_diff; ];
if (g_bg_diff > precision) [ bg_matches_ref = 0; ];

variable b_bg_diff: Number = bg.b - ref.b;
if (b_bg_diff < 0) [ b_bg_diff = 0 - b_bg_diff; ];
if (b_bg_diff > precision) [ bg_matches_ref = 0; ];

if (bg_matches_ref == 1) [
    alpha = 0;
    in_range = 1;
] else [
    if (valid_channels > 0) [
        alpha = alpha_sum / valid_channels;
        
        // Validate: check if channels agree within precision
        variable channels_agree: Number = 1;
        if (r_alpha >= 0) [
            if (r_alpha <= 1) [
                variable r_diff_check: Number = r_alpha - alpha;
                if (r_diff_check < 0) [ r_diff_check = 0 - r_diff_check; ];
                if (r_diff_check > precision * 10) [ channels_agree = 0; ];
            ];
        ];
        if (g_alpha >= 0) [
            if (g_alpha <= 1) [
                variable g_diff_check: Number = g_alpha - alpha;
                if (g_diff_check < 0) [ g_diff_check = 0 - g_diff_check; ];
                if (g_diff_check > precision * 10) [ channels_agree = 0; ];
            ];
        ];
        if (b_alpha >= 0) [
            if (b_alpha <= 1) [
                variable b_diff_check: Number = b_alpha - alpha;
                if (b_diff_check < 0) [ b_diff_check = 0 - b_diff_check; ];
                if (b_diff_check > precision * 10) [ channels_agree = 0; ];
            ];
        ];
        
        if (channels_agree == 1) [
            in_range = 1;
        ];
    ];
];

// Return as list: [in_range, alpha, foreground_color]
// Foreground is returned unchanged - user applies alpha in their working space
variable result: List = in_range, alpha, input.get(0);
return result;
